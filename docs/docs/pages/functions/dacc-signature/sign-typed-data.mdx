# Sign Typed Data (daccSignTypedData) [A function to sign EIP-712 typed data]

The `daccSignTypedData` function allows you to **sign EIP-712 typed data** using a Dacc wallet or provided account. It creates a wallet client and signs structured data according to the EIP-712 standard, returning the signature with metadata.

## Import

```ts 
import { daccSignTypedData } from 'dacc-js';
```

## Usage

```ts 
import { daccSignTypedData } from 'dacc-js';
// [!code word:optimismSepolia]
import { optimismSepolia } from 'viem/chains'; // used `viem` - npm i viem

const signedData = await daccSignTypedData({
  // account: "0xPrivatekey...", // Can call with `allowDaccWallet` function
  daccPublickey: 'daccPublickey_0x123_XxX..',
  // address: "0xYourAccountAddress..", // Only the address created is set to `publicEncryption: true`
  passwordSecretkey: 'my+Password#123..',
  network: optimismSepolia,
  domain: { 
    name: 'MyApp', 
    version: '1',
    chainId: 11155420,
    verifyingContract: '0xContract...'
  },
  types: { 
    Message: [
      { name: 'content', type: 'string' },
      { name: 'timestamp', type: 'uint256' }
    ] 
  },
  primaryType: 'Message',
  message: { 
    content: 'Hello World',
    timestamp: 1638360000
  }
});

console.log(signedData); // {signature, chainId, from, domain, types, message}
console.log(signedData?.signature); // 0x1234abcd... (signature)
```

### Arguments
| Parameter | Type | Description |
| :--- | :--- | :--- |
| **`account`** | `Account` or `0x${string}` | Conditional: The account to use for signing (Account object is private key). |
| **`daccPublickey`** | `string` | Conditional: The encrypted wallet data from `createDaccWallet`. |
| **`address`** | `0x${string}` | Conditional: wallet address from a created with `createDaccWallet` in `publicEncryption: true` mode (can use instead of daccPublickey). |
| **`passwordSecretkey`** | `string` | Conditional: The user's password used to decrypt the wallet. |
| **`network`** | `Chain` | The blockchain network configuration. |
| **`domain`** | `Record<string, any>` | Optional: The EIP-712 domain object. |
| **`types`** | `Record<string, any>` | Optional: The EIP-712 types definition. |
| **`primaryType`** | `string` | Optional: The primary type for the message. |
| **`message`** | `Record<string, any>` | Optional: The message data to sign. |

## Return Value
The response result is an object containing `{signature, chainId, from, domain, types, message}`

## Parameters

### account (conditional)

- **Type:** `Account` | `0x${string}`

The user's account to use for signing the typed data.

:::note
When using the `account` parameter, you **don't need** to provide `address`, `daccPublickey`, or `passwordSecretkey`. The account contains the private key needed for signing directly.
:::

```ts
const signedData = await daccSignTypedData({
  account: "0xPrivatekey...", // [!code focus]
//   address: '0x123...', // [!code --]
//   daccPublickey: 'daccPublickey_0x123_XxX..', // [!code --]
//   passwordSecretkey: 'my+Password#123..', // [!code --]
  network: optimismSepolia,
  domain: { name: 'MyApp', version: '1' },
  types: { Message: [{ name: 'content', type: 'string' }] },
  primaryType: 'Message',
  message: { content: 'Hello World' }
});
```

### daccPublickey (conditional)

- **Type:** `string`

The user's encrypted public key to address.

> *daccPublickey is the most reliable addressing solution and supports all types of data storage using `daccPublickey`.*

:::note
When using `daccPublickey`, you **must also provide** `passwordSecretkey` to decrypt the wallet., Remove the `account` parameter when using this method.
:::

```ts
const signedData = await daccSignTypedData({
//   account: "0xPrivatekey...", // [!code --]
  daccPublickey: 'daccPublickey_0x123_XxX..', // [!code focus]
  passwordSecretkey: 'my+Password#123..', // [!code ++]
  network: optimismSepolia,
  domain: { name: 'MyApp', version: '1' },
  types: { Message: [{ name: 'content', type: 'string' }] },
  primaryType: 'Message',
  message: { content: 'Hello World' }
});
```
*daccPublickey is the most reliable addressing solution and supports all types of data storage using `daccPublickey`.*

### address (optional)

- **Type:** `0x${string}`

The encrypted wallet data returned from `createDaccWallet`.

:::note
When using `address`, you **must also provide** `passwordSecretkey` to decrypt the wallet. Remove the `account` parameter when using this method. You can use either `address` or `daccPublickey` - both require the same password.
:::

```ts
const signedData = await daccSignTypedData({
//   account: "0xPrivatekey...", // [!code --]
//   daccPublickey: 'daccPublickey_0x123_XxX..', // Match with address
  address: '0x123address...', // [!code focus] Only the address created is set to `publicEncryption: true`
  passwordSecretkey: 'my+Password#123..', // [!code ++]
  network: optimismSepolia,
  domain: { name: 'MyApp', version: '1' },
  types: { Message: [{ name: 'content', type: 'string' }] },
  primaryType: 'Message',
  message: { content: 'Hello World' }
});
```

### passwordSecretkey (conditional)

- **Type:** `string`

The same password used when creating the wallet.

:::info
Make sure to use the exact same password that was used with `createDaccWallet`.
:::

```ts
const signedData = await daccSignTypedData({
  daccPublickey: 'daccPublickey_0x123_XxX..',
  passwordSecretkey: 'my+Password#123..', // [!code focus]
  network: optimismSepolia,
  domain: { name: 'MyApp', version: '1' },
  types: { Message: [{ name: 'content', type: 'string' }] },
  primaryType: 'Message',
  message: { content: 'Hello World' }
});
```

### network

- **Type:** `Chain`

The blockchain network configuration.

:::note
Use Chain objects from `viem/chains` (e.g., `mainnet`, `sepolia`, `optimismSepolia`) or define your own custom chain configuration.
:::

::::note[Custom Chain Network]
When using [customChain](/concept/mechanical#custom-networks) click to details.
:::details
```ts
import { defineChain } from "viem";

const myCustomChain = defineChain({
  id: 123456,
  name: "My Custom Chain",
  network: "myCustomChain",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-example.com"] }
  },
  blockExplorers: {
    default: { name: 'Explorer', url: 'https://explorer-example.com' },
  },
});
```
:::
::::

```ts
const signedData = await daccSignTypedData({
  daccPublickey: 'daccPublickey_0x123_XxX..',
  address: '0x123...',
  passwordSecretkey: 'my+Password#123..',
  network: optimismSepolia, // [!code focus]
  // network: myCustomChain, // [!code hl] For Custom Chain Network
  domain: { name: 'MyApp', version: '1' },
  types: { Message: [{ name: 'content', type: 'string' }] },
  primaryType: 'Message',
  message: { content: 'Hello World' }
});
```

### domain (optional)

- **Type:** `Record<string, any>`
- **Default:** `undefined`

The EIP-712 domain object that defines the context for the signed data.

:::note
The domain typically includes `name`, `version`, `chainId`, and `verifyingContract`. This helps prevent signature replay attacks across different applications or networks.
:::

```ts
const signedData = await daccSignTypedData({
  daccPublickey: 'daccPublickey_0x123_XxX..',
  address: '0x123...',
  passwordSecretkey: 'my+Password#123..',
  network: optimismSepolia,
  domain: { // [!code focus]
    name: 'MyDApp',
    version: '1.0.0',
    chainId: 11155420,
    verifyingContract: '0xContract...'
  }, // [!code focus]
  types: { Message: [{ name: 'content', type: 'string' }] },
  primaryType: 'Message',
  message: { content: 'Hello World' }
});
```

### types (optional)

- **Type:** `Record<string, any>`
- **Default:** `undefined`

The EIP-712 types definition that describes the structure of the data being signed.

:::note
Define the structure of your custom types. Each type should specify the name and Solidity type for each field.
:::

```ts
const signedData = await daccSignTypedData({
  daccPublickey: 'daccPublickey_0x123_XxX..',
  address: '0x123...',
  passwordSecretkey: 'my+Password#123..',
  network: optimismSepolia,
  domain: { name: 'MyApp', version: '1' },
  types: { // [!code focus]
    Person: [
      { name: 'name', type: 'string' },
      { name: 'age', type: 'uint256' }
    ],
    Message: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'content', type: 'string' }
    ]
  }, // [!code focus]
  primaryType: 'Message',
  message: { 
    from: { name: 'Alice', age: 25 },
    to: { name: 'Bob', age: 30 },
    content: 'Hello Bob!'
  }
});
```

### primaryType (optional)

- **Type:** `string`
- **Default:** `undefined`

The primary type for the message being signed.

:::note
This should match one of the types defined in your `types` object. It tells the signing function which type structure to use for the main message.
:::

```ts
const signedData = await daccSignTypedData({
  daccPublickey: 'daccPublickey_0x123_XxX..',
  address: '0x123...',
  passwordSecretkey: 'my+Password#123..',
  network: optimismSepolia,
  domain: { name: 'MyApp', version: '1' },
  types: { 
    Message: [{ name: 'content', type: 'string' }],
    Order: [{ name: 'amount', type: 'uint256' }]
  },
  primaryType: 'Message', // [!code focus] Must match one of the types above
  message: { content: 'Hello World' }
});
```

### message (optional)

- **Type:** `Record<string, any>`
- **Default:** `undefined`

The message data to sign, structured according to the primaryType definition.

:::note
The message structure must match the type definition specified in the `primaryType` and `types` parameters.
:::

```ts
const signedData = await daccSignTypedData({
  daccPublickey: 'daccPublickey_0x123_XxX..',
  address: '0x123...',
  passwordSecretkey: 'my+Password#123..',
  network: optimismSepolia,
  domain: { name: 'MyApp', version: '1' },
  types: { 
    Message: [
      { name: 'content', type: 'string' },
      { name: 'timestamp', type: 'uint256' },
      { name: 'priority', type: 'bool' }
    ]
  },
  primaryType: 'Message',
  message: { // [!code focus]
    content: 'Hello World',
    timestamp: 1638360000,
    priority: true
  } // [!code focus]
});
```

## Examples

### Simple message signing

```ts
const signedData = await daccSignTypedData({
  daccPublickey: 'daccPublickey_0x123_XxX..',
  address: '0x123...',
  passwordSecretkey: 'my+Password#123..',
  network: optimismSepolia,
  domain: {
    name: 'ChatApp',
    version: '1.0.0'
  },
  types: {
    Message: [
      { name: 'content', type: 'string' },
      { name: 'timestamp', type: 'uint256' }
    ]
  },
  primaryType: 'Message',
  message: {
    content: 'Hello, this is a signed message!',
    timestamp: Math.floor(Date.now() / 1000)
  }
});

console.log(`Signature: ${signedData.signature}`);
console.log(`Signed by: ${signedData.from}`);
```

### NFT marketplace order signing

```ts
const signedData = await daccSignTypedData({
  account: "0xYourPrivateKey...",
  network: optimismSepolia,
  domain: {
    name: 'NFT Marketplace',
    version: '2.0.0',
    chainId: 11155420,
    verifyingContract: '0xMarketplaceContract...'
  },
  types: {
    Order: [
      { name: 'tokenContract', type: 'address' },
      { name: 'tokenId', type: 'uint256' },
      { name: 'price', type: 'uint256' },
      { name: 'seller', type: 'address' },
      { name: 'nonce', type: 'uint256' },
      { name: 'expiry', type: 'uint256' }
    ]
  },
  primaryType: 'Order',
  message: {
    tokenContract: '0xNFTContract...',
    tokenId: 123,
    price: BigInt('1000000000000000000'), // 1 ETH in wei
    seller: '0x123...',
    nonce: 1,
    expiry: Math.floor(Date.now() / 1000) + 3600 // 1 hour from now
  }
});

console.log(`Order signature: ${signedData.signature}`);
```

### Multi-type message signing

```ts
const signedData = await daccSignTypedData({
  daccPublickey: 'daccPublickey_0x123_XxX..',
  address: '0x123...',
  passwordSecretkey: 'my+Password#123..',
  network: optimismSepolia,
  domain: {
    name: 'Social Media DApp',
    version: '1.0.0'
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' }
    ],
    Post: [
      { name: 'author', type: 'Person' },
      { name: 'content', type: 'string' },
      { name: 'timestamp', type: 'uint256' },
      { name: 'likes', type: 'uint256' }
    ]
  },
  primaryType: 'Post',
  message: {
    author: {
      name: 'Alice',
      wallet: '0x123...'
    },
    content: 'This is my first post on the blockchain!',
    timestamp: Math.floor(Date.now() / 1000),
    likes: 0
  }
});

console.log(`Post signed successfully: ${signedData.signature}`);
```

### Token permit signing

```ts
const signedData = await daccSignTypedData({
  daccPublickey: 'daccPublickey_0x123_XxX..',
  address: '0x123...',
  passwordSecretkey: 'my+Password#123..',
  network: optimismSepolia,
  domain: {
    name: 'USD Coin',
    version: '2',
    chainId: 11155420,
    verifyingContract: '0xUSDCContract...'
  },
  types: {
    Permit: [
      { name: 'owner', type: 'address' },
      { name: 'spender', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'deadline', type: 'uint256' }
    ]
  },
  primaryType: 'Permit',
  message: {
    owner: '0x123...',
    spender: '0xSpenderContract...',
    value: BigInt('1000000000'), // 1000 USDC (6 decimals)
    nonce: 0,
    deadline: Math.floor(Date.now() / 1000) + 3600 // 1 hour from now
  }
});

console.log(`Permit signature: ${signedData.signature}`);
```

### Voting signature

```ts
const signedData = await daccSignTypedData({
  account: "0xPrivateKey...",
  network: optimismSepolia,
  domain: {
    name: 'DAO Governance',
    version: '1.0.0',
    chainId: 11155420,
    verifyingContract: '0xGovernanceContract...'
  },
  types: {
    Vote: [
      { name: 'proposalId', type: 'uint256' },
      { name: 'support', type: 'uint8' },
      { name: 'voter', type: 'address' },
      { name: 'nonce', type: 'uint256' }
    ]
  },
  primaryType: 'Vote',
  message: {
    proposalId: 42,
    support: 1, // 0 = Against, 1 = For, 2 = Abstain
    voter: '0x123...',
    nonce: 1
  }
});

console.log(`Vote signature: ${signedData.signature}`);
console.log(`Vote metadata:`, signedData.message);
```
